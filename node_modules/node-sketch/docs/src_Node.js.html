<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>src/Node.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Attributes.html">Attributes</a><ul class='methods'><li data-type='method'><a href="Attributes.html#clone">clone</a></li><li data-type='method'><a href="Attributes.html#detach">detach</a></li><li data-type='method'><a href="Attributes.html#get">get</a></li><li data-type='method'><a href="Attributes.html#getAll">getAll</a></li><li data-type='method'><a href="Attributes.html#getParent">getParent</a></li><li data-type='method'><a href="Attributes.html#getSketch">getSketch</a></li><li data-type='method'><a href="Attributes.html#push">push</a></li><li data-type='method'><a href="Attributes.html#replaceWith">replaceWith</a></li><li data-type='method'><a href="Attributes.html#set">set</a></li><li data-type='method'><a href="Attributes.html#toJson">toJson</a></li></ul></li><li><a href="FileReference.html">FileReference</a><ul class='methods'><li data-type='method'><a href="FileReference.html#clone">clone</a></li><li data-type='method'><a href="FileReference.html#detach">detach</a></li><li data-type='method'><a href="FileReference.html#export">export</a></li><li data-type='method'><a href="FileReference.html#get">get</a></li><li data-type='method'><a href="FileReference.html#getAll">getAll</a></li><li data-type='method'><a href="FileReference.html#getParent">getParent</a></li><li data-type='method'><a href="FileReference.html#getSketch">getSketch</a></li><li data-type='method'><a href="FileReference.html#push">push</a></li><li data-type='method'><a href="FileReference.html#replaceWith">replaceWith</a></li><li data-type='method'><a href="FileReference.html#set">set</a></li><li data-type='method'><a href="FileReference.html#toJson">toJson</a></li></ul></li><li><a href="Node.html">Node</a><ul class='methods'><li data-type='method'><a href="Node.html#clone">clone</a></li><li data-type='method'><a href="Node.html#detach">detach</a></li><li data-type='method'><a href="Node.html#get">get</a></li><li data-type='method'><a href="Node.html#getAll">getAll</a></li><li data-type='method'><a href="Node.html#getParent">getParent</a></li><li data-type='method'><a href="Node.html#getSketch">getSketch</a></li><li data-type='method'><a href="Node.html#push">push</a></li><li data-type='method'><a href="Node.html#replaceWith">replaceWith</a></li><li data-type='method'><a href="Node.html#set">set</a></li><li data-type='method'><a href="Node.html#toJson">toJson</a></li></ul></li><li><a href="Sketch.html">Sketch</a><ul class='methods'><li data-type='method'><a href="Sketch.html#save">save</a></li><li data-type='method'><a href="Sketch.html#saveDir">saveDir</a></li></ul></li><li><a href="Style.html">Style</a><ul class='methods'><li data-type='method'><a href="Style.html#applySharedStyle">applySharedStyle</a></li><li data-type='method'><a href="Style.html#clone">clone</a></li><li data-type='method'><a href="Style.html#detach">detach</a></li><li data-type='method'><a href="Style.html#get">get</a></li><li data-type='method'><a href="Style.html#getAll">getAll</a></li><li data-type='method'><a href="Style.html#getParent">getParent</a></li><li data-type='method'><a href="Style.html#getSketch">getSketch</a></li><li data-type='method'><a href="Style.html#push">push</a></li><li data-type='method'><a href="Style.html#replaceWith">replaceWith</a></li><li data-type='method'><a href="Style.html#set">set</a></li><li data-type='method'><a href="Style.html#toJson">toJson</a></li></ul></li><li><a href="SymbolInstance.html">SymbolInstance</a><ul class='methods'><li data-type='method'><a href="SymbolInstance.html#clone">clone</a></li><li data-type='method'><a href="SymbolInstance.html#detach">detach</a></li><li data-type='method'><a href="SymbolInstance.html#get">get</a></li><li data-type='method'><a href="SymbolInstance.html#getAll">getAll</a></li><li data-type='method'><a href="SymbolInstance.html#getParent">getParent</a></li><li data-type='method'><a href="SymbolInstance.html#getSketch">getSketch</a></li><li data-type='method'><a href="SymbolInstance.html#push">push</a></li><li data-type='method'><a href="SymbolInstance.html#replaceWith">replaceWith</a></li><li data-type='method'><a href="SymbolInstance.html#set">set</a></li><li data-type='method'><a href="SymbolInstance.html#toJson">toJson</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#read">read</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">src/Node.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const _parent = Symbol.for('Parent');
const lib = require('../');
const Sketch = require('./Sketch');
const layers = {
    classes: [
        'artboard',
        'bitmap',
        'group',
        'oval',
        'page',
        'polygon',
        'rectangle',
        'shapeGroup',
        'shapePath',
        'slice',
        'star',
        'symbolInstance',
        'symbolMaster',
        'text',
        'triangle'
    ],
    page: ['symbolMaster', 'artboard']
};

/**
 * Abstract class that it's used by all other classes, providing basic functionalities.
 *
 * @abstract
 */
class Node {
    /**
     * @constructor
     *
     * @param  {Node|Sketch} parent - The parent of the element
     * @param  {Object} data - The raw data from the sketch file
     */
    constructor(parent, data) {
        this[_parent] = parent;

        Object.keys(data).forEach(key => this.set(key, data[key]));
    }

    /**
     * Returns the parent element
     *
     * @return {Node|Sketch|undefined}
     */
    get parent() {
        return this[_parent];
    }

    /**
     * Find a node ascendent matching with the type and condition
     *
     * @param  {String} [type] - The node type
     * @param  {Function|String} [condition] - The node name or a callback to be executed on each parent and must return true or false. If it's not provided, only the type argument is be used.
     * @return {Node|Sketch|undefined}
     */
    getParent(type, condition) {
        let parent = this[_parent];

        condition = getCondition(type, condition);

        if (!condition) {
            return parent;
        }

        while (parent &amp;&amp; !condition(parent)) {
            parent = parent[_parent];
        }

        return parent;
    }

    /**
     * Get the sketch element associated with this node
     *
     * @return {Sketch|undefined}
     */
    getSketch() {
        let parent = this;

        while (parent[_parent]) {
            parent = parent[_parent];
        }

        if (parent instanceof Sketch) {
            return parent;
        }
    }

    /**
     * Add/replace new childrens in this node
     * @param {string} key  The node key
     * @param {Node|Object|Array} node The node/s to insert
     */
    set(key, node) {
        if (node instanceof Node) {
            node = node.toJson();
        }

        if (isPlainObject(node)) {
            //is a subclass
            if ('_class' in node) {
                this[key] = lib.create(this, node);
                return;
            }

            this[key] = {};

            Object.keys(node).forEach(k => {
                if (typeof node[k] === 'object' &amp;&amp; '_class' in node[k]) {
                    this[key][k] = lib.create(this, node[k]);
                } else {
                    this[key][k] = node[k];
                }
            });
            return;
        }

        //is an array of subclasses
        if (Array.isArray(node) &amp;&amp; typeof node[0] === 'object' &amp;&amp; '_class' in node[0]) {
            this[key] = node.map(child => lib.create(this, child));
            return;
        }

        this[key] = node;
    }

    /**
     * Push a new children in this node
     * @param {string} key The node key
     * @param {Node|Object} node The node/s to insert
     *
     * @return {Node} The new node inserted
     */
    push(key, node) {
        if (node instanceof Node) {
            node = node.toJson();
        }

        if (!Array.isArray(this[key])) {
            throw new Error(`Unable to push new children. ${key} must be an array`);
        }

        //is a subclass
        if (typeof node === 'object' &amp;&amp; '_class' in node) {
            node = lib.create(this, node);
        }

        this[key].push(node);

        return node;
    }

    /**
     * Search and returns the first descendant node that match the type and condition.
     *
     * @param  {String} type - The Node type
     * @param  {Function|String} [condition] - The node name or a callback to be executed on each node that must return true or false. If it's not provided, only the type argument is be used.
     * @return {Node|undefined}
     */
    get(type, condition) {
        //page has always as direct children artboard and symbolMasters
        if (layers[this._class] &amp;&amp; layers[this._class].indexOf(type) !== -1) {
            return this.layers.find(getCondition(type, condition));
        }

        if (layers.classes.indexOf(type) === -1) {
            return findNode(this, getCondition(type, condition));
        }

        return findLayer(this, getCondition(type, condition));
    }

    /**
     * Search and returns all descendant nodes matching with the type and condition.
     * @example
     * //Get the first page
     * const page = sketch.pages[0];
     *
     * //Get all colors found in this page
     * const colors = page.getAll('color');
     *
     * //Get all colors with specific values
     * const blueColors = page.getAll('color', (color) => {
     *  return color.blue > 0.5 &amp;&amp; color.red &lt; 0.33
     * });
     *
     * @param  {String} type - The Node type
     * @param  {Function|String} [condition] - The node name or a callback to be executed on each node that must return true or false. If it's not provided, only the type argument is be used.
     * @return {Node[]}
     */
    getAll(type, condition, result) {
        //page has always as direct children artboard and symbolMasters
        if (layers[this._class] &amp;&amp; layers[this._class].indexOf(type) !== -1) {
            return this.layers.filter(getCondition(type, condition));
        }

        result = result || [];

        if (layers.classes.indexOf(type) === -1) {
            return findNode(this, getCondition(type, condition), result);
        }

        return findLayer(this, getCondition(type, condition), result);
    }

    /**
     * Removes the node from its parent
     *
     * @return {Node}
     */
    detach() {
        const parent = this[_parent];
        this[_parent] = undefined;

        if (!parent) {
            throw new Error('Unable to detach a node without parent');
        }

        for (let [key, value] of Object.entries(parent)) {
            if (value === this) {
                parent[key] = undefined;
                return this;
            }

            if (Array.isArray(value)) {
                const index = value.indexOf(this);

                if (index !== -1) {
                    value.splice(index, 1);
                    return this;
                }
            }
        }

        throw new Error('Unable to detach a node with incorrect parent');
    }

    /**
     * Replace this node with other
     *
     * @param {Node} node - The node to use
     *
     * @return {Node} The new node
     */
    replaceWith(node) {
        const parent = this[_parent];

        if (!parent) {
            throw new Error('Unable to replace a node without parent');
        }

        node[_parent] = parent;

        for (let [key, value] of Object.entries(parent)) {
            if (value === this) {
                parent[key] = node;
                return node;
            }

            if (Array.isArray(value)) {
                const index = value.indexOf(this);

                if (index !== -1) {
                    value[index] = node;
                    return node;
                }
            }
        }

        throw new Error('Unable to replace a node with incorrect parent');
    }

    /**
     * Creates a deep clone of this node
     *
     * @param {Node|undefined} parent - The new parent of the clone. If it's not defined use the current parent.
     *
     * @return {Node}
     */
    clone(parent) {
        return lib.create(parent || this.parent, this.toJson());
    }

    /**
     * Returns a json with the node data
     *
     * @return {Object}
     */
    toJson() {
        return JSON.parse(JSON.stringify(this));
    }
}

module.exports = Node;

function getCondition(type, condition) {
    if (!type) {
        return false;
    }

    if (typeof type === 'function') {
        return type;
    }

    if (!condition) {
        return node => node._class === type;
    }

    if (typeof condition === 'string') {
        return node => node._class === type &amp;&amp; node.name === condition;
    }

    return node => node._class === type &amp;&amp; condition(node);
}

function findNode(target, condition, result) {
    for (let [key, value] of Object.entries(target)) {
        if (value instanceof Node) {
            if (!condition || condition(value)) {
                if (result) {
                    result.push(value);
                    continue;
                }

                return value;
            }

            if (result) {
                findNode(value, condition, result);
                continue;
            }

            const found = findNode(value, condition);

            if (found) {
                return found;
            }

            continue;
        }

        if (Array.isArray(value)) {
            for (let child of value) {
                if (child instanceof Node) {
                    if (!condition || condition(child)) {
                        if (result) {
                            result.push(child);
                            continue;
                        }

                        return child;
                    }

                    if (result) {
                        findNode(child, condition, result);
                        continue;
                    }

                    const found = findNode(child, condition);

                    if (found) {
                        return found;
                    }
                }
            }

            continue;
        }

        if (isPlainObject(value)) {
            if (result) {
                findNode(value, condition, result);
                continue;
            }

            const found = findNode(value, condition);

            if (found) {
                return found;
            }
        }
    }

    return result;
}

function findLayer(target, condition, result) {
    if (result) {
        target.layers.filter(layer => !condition || condition(layer)).forEach(layer => result.push(layer));
    } else {
        let layer = target.layers.find(layer => !condition || condition(layer));

        if (layer) {
            return layer;
        }
    }

    for (let [key, value] of Object.entries(target.layers)) {
        if ('layers' in value) {
            if (result) {
                findLayer(value, condition, result);
            } else {
                const found = findLayer(value, condition);

                if (found) {
                    return found;
                }
            }
        }
    }

    return result;
}

//https://stackoverflow.com/a/38555871
function isPlainObject(obj) {
    return (
        typeof obj === 'object' &amp;&amp;
        obj !== null &amp;&amp;
        obj.constructor === Object &amp;&amp;
        Object.prototype.toString.call(obj) === '[object Object]'
    );
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Dec 24 2018 14:13:01 GMT+0100 (hora estándar de Europa central) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>


</body>
</html>
